Assembly Instructions (extended instruction set)

Arithmetic/Logical Instructions

ADDi @A @B //@A is memory address, @B is data literal, result stored in @A
ADDm @A @B //@A is memory address, @B is memory address, result stored in @A
SUBi @A @B //@A is memory address, @B is data literal, result stored in @A
SUBm @A @B //@A is memory address, @B is memory address, result stored in @A
INC @A //@A is the address of the variable to be incremented
DEC @A //@A is the address of the variable to be decremented
BSL @A //@A is the address of the variable to be bit shifted left
BSR @A //@A is the address of the variable to be bit shifted right
NEG @A //@A is the address of the variable to be negated arithmetically
NANDi @A @B //@A is memory address, @B is data literal, result stored in @A
NANDm @A @B //@A is memory address, @B is memory address, result stored in @A
ANDi @A @B //@A is memory address, @B is data literal, result stored in @A
ANDm @A @B //@A is memory address, @B is memory address, result stored in @A
ORi @A @B //@A is memory address, @B is data literal, result stored in @A
ORm @A @B //@A is memory address, @B is memory address, result stored in @A
XORi @A @B //@A is memory address, @B is data literal, result stored in @A
XORm @A @B //@A is memory address, @B is memory address, result stored in @A
NOT @A //@A is the address of the variable to be negated logically

Memory Instructions

PUSHi @A //@A is data literal
PUSHm @A //@A is memory address
POP @A //@A is a memory address
LOADi @A @B //@A is data literal, @B is memory address
MOV @A @B //@A is memory address, @B is memory address

I/O Instructions

SENDi @A //@A is data literal
SENDm @A //@A is memory address
READ @A //@A is memory address

Program Control Instructions

BOFi @A @B @C //@A is memory address, @B is data literal, and @C is memory location literal
BOFm @A @B @C //@A is memory address, @B is memory address, and @C is memory location literal
BEQi @A @B @C //@A is memory address, @B is data literal, and @C is memory location literal
BEQm @A @B @C //@A is memory address, @B is memory address, and @C is memory location literal
BGTi @A @B @C //@A is memory address, @B is data literal, and @C is memory location literal
BGTm @A @B @C //@A is memory address, @B is memory address, and @C is memory location literal
BLTi @A @B @C //@A is memory address, @B is data literal, and @C is memory location literal
BLTm @A @B @C //@A is memory address, @B is memory address, and @C is memory location literal
BNEQi @A @B @C //@A is memory address, @B is data literal, and @C is memory location literal
BNEQm @A @B @C //@A is memory address, @B is memory address, and @C is memory location literal
GOTO @A //@A is memory location literal

Miscellaneous Instructions

HALT
NOP

The assembly also supports two types of labels:

The first is a program label. The syntax looks like this:

label _IDENTIFIER_ = here

_IDENTIFIER_ can now be used in any program control statements to reference to this location in the linear progression of assembly code.

The second type of label is a variable label. The syntax looks like this:

label _IDENTIFIER_ = @A

@A is the address in data memory of the variable to be stored. Although the syntax is similar, the two labels serve very different purposes.
Labels do NOT need to be defined before they are used in assembly. The assembler makes an initial pass over the source to construct a symbol table.
The assembler does NOT manage memory allocation, so either the programmer or the compiler is responsible for correctly manipulating memory.

The assembler also supports the definition of macroinstructions outside of the default language package. These "functions" are inserted INLINE, and not handled with subroutines/procedures. Macros must be defined in the beginning of the file, and must follow the formula:

MACRO _IDENTIFIER_ [@0 [@1 [@2...]]]
//CODE
END

Again, the programmer is responsible for dealing with any memory conflicts that result. Inbuilt assembly macroinstructions are guaranteed to be safe.

Comments in assembly are prefaced with //
Each statement should be separated by a newline character.
The very first noncomment line in the file must contain the actual line in program memory onto which the program will be loaded, in the format:

@1A9F

Where the location is specified in hexidecimal.

Identify all memory locations in the form @0000 where 0000 is the address in hexadecimal.
Identify all literal values in the form x0000 or d00000 or b0000000000000000.